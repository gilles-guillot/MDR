distribution = "binom")
MDR_sim[j,] = res$MDR_resamp
# ## loop on simulated data
# for(isim in 1:nsim)
# {
#   print(paste('mixture',j,'sim',isim))
#   ## simulate data
#   simdat = Sim_Mixture(x=x,y=y,n=n,
#                        par_Hill=c(a1=dallabona.sc$EC50[i.a],
#                                   b1=dallabona.sc$Hill.Slope[i.a],
#                                   a2=dallabona.sc$EC50[i.b],
#                                   b2=dallabona.sc$Hill.Slope[i.b]),
#                        interaction_model="Loewe",
#                        par_int=NULL,
#                        distribution="binom")
#   ## Compute MDR on simulated data
#   res_MDR = Compute_MDR(x=x,y=y,
#                         z=simdat$z,n=n,
#                         models=c('Hill2'),
#                         design='single-ray',
#                         lower = c(0.0001,0.0001,0.0001,0.0001) ,
#                         upper = c(1000,100,1,1) ,
#                         do.plot=F)
#   MDR_sim[j,isim] = res_MDR['MDR']
#   save(MDR_obs,MDR_sim,
#        file="~/tmp/dallabona.Rdat")
# }## end loop on simulated data
}
}
save(MDR_obs,file='./data/MDR_obs.rda')
save(MDR_sim,file='./data/MDR_sim.rda')
# save(MDR_obs,MDR_sim,
#      file="/home/gilles/Dropbox/iPRI/projects/Dose_Response_Curves/Real_Data/Crustacea_Included_InDatabase/dallabona.Rdat")
MDR_sim
document()
document()
build()
install()
setwd("/home/gilles/Dropbox/iPRI/projects/ToxPharm/MDR_package/MDR")
## connect local project or github repo
#
library(MDR)
MDR_sim
row.names(MDR_sim)
dim(row.names())
dim(row.names)
dim(MDR_obs)
row.names(MDR_sim)
dim(MDR_sim)
for(i in 1:4) ## loop on the four compound combinations
{
names = unique(dallabona.mix[,1:2])[i,]
name.a = unlist(names[1]) ; name.b = unlist(names[2])
i.a = dallabona.sc[,1] == name.a # where to find info in single compound data dallabona.sc
r =  (dallabona.sc[i.a,'max'] / dallabona.sc[i.a,'min'])^(1/4)
dsc.a = dallabona.sc[i.a,'min'] * c(1,r,r^2,r^3,r^4)
i.b = dallabona.sc[,1] == name.b
r =  (dallabona.sc[i.b,'max'] / dallabona.sc[i.b,'min'])^(1/4)
dsc.b = dallabona.sc[i.b,'min'] * c(1,r,r^2,r^3,r^4)
for(j in (1:12)[dallabona.mix[,1] == name.a &  dallabona.mix[,2] == name.b] ) # loop on the compound combination x mixture proportions
{
w.max = dallabona.mix[j,'max.b'] / dallabona.mix[j,'max.a']
}
}
## naming rows ex-post
nn = rep("",12)
ii = 1
for(i in 1:4) ## loop on the four compound combinations
{
names = unique(dallabona.mix[,1:2])[i,]
name.a = unlist(names[1]) ; name.b = unlist(names[2])
i.a = dallabona.sc[,1] == name.a # where to find info in single compound data dallabona.sc
r =  (dallabona.sc[i.a,'max'] / dallabona.sc[i.a,'min'])^(1/4)
dsc.a = dallabona.sc[i.a,'min'] * c(1,r,r^2,r^3,r^4)
i.b = dallabona.sc[,1] == name.b
r =  (dallabona.sc[i.b,'max'] / dallabona.sc[i.b,'min'])^(1/4)
dsc.b = dallabona.sc[i.b,'min'] * c(1,r,r^2,r^3,r^4)
for(j in (1:12)[dallabona.mix[,1] == name.a &  dallabona.mix[,2] == name.b] ) # loop on the compound combination x mixture proportions
{
w.max = dallabona.mix[j,'max.b'] / dallabona.mix[j,'max.a']
nn[ii] = paste(name.a,name.b,w.max)
ii = ii + 1
}
}
nn
## naming rows ex-post
nn = rep("",12)
ii = 1
for(i in 1:4) ## loop on the four compound combinations
{
names = unique(dallabona.mix[,1:2])[i,]
name.a = unlist(names[1]) ; name.b = unlist(names[2])
i.a = dallabona.sc[,1] == name.a # where to find info in single compound data dallabona.sc
r =  (dallabona.sc[i.a,'max'] / dallabona.sc[i.a,'min'])^(1/4)
dsc.a = dallabona.sc[i.a,'min'] * c(1,r,r^2,r^3,r^4)
i.b = dallabona.sc[,1] == name.b
r =  (dallabona.sc[i.b,'max'] / dallabona.sc[i.b,'min'])^(1/4)
dsc.b = dallabona.sc[i.b,'min'] * c(1,r,r^2,r^3,r^4)
for(j in (1:12)[dallabona.mix[,1] == name.a &  dallabona.mix[,2] == name.b] ) # loop on the compound combination x mixture proportions
{
w.max = dallabona.mix[j,'max.b'] / dallabona.mix[j,'max.a']
nn[ii] = paste(name.a,name.b,signif(w.maxn,dig=2))
ii = ii + 1
}
}
## naming rows ex-post
nn = rep("",12)
ii = 1
for(i in 1:4) ## loop on the four compound combinations
{
names = unique(dallabona.mix[,1:2])[i,]
name.a = unlist(names[1]) ; name.b = unlist(names[2])
i.a = dallabona.sc[,1] == name.a # where to find info in single compound data dallabona.sc
r =  (dallabona.sc[i.a,'max'] / dallabona.sc[i.a,'min'])^(1/4)
dsc.a = dallabona.sc[i.a,'min'] * c(1,r,r^2,r^3,r^4)
i.b = dallabona.sc[,1] == name.b
r =  (dallabona.sc[i.b,'max'] / dallabona.sc[i.b,'min'])^(1/4)
dsc.b = dallabona.sc[i.b,'min'] * c(1,r,r^2,r^3,r^4)
for(j in (1:12)[dallabona.mix[,1] == name.a &  dallabona.mix[,2] == name.b] ) # loop on the compound combination x mixture proportions
{
w.max = dallabona.mix[j,'max.b'] / dallabona.mix[j,'max.a']
nn[ii] = paste(name.a,name.b,signif(w.max,dig=2))
ii = ii + 1
}
}
nn
row.names(MDR_sim) = nn
str(MDR_sim)
save(MDR_sim,file='./data/MDR_sim.rda')
library(MDR)
library(ggplot2)
library(gridExtra)
# library(bookdown)
cdf_mdr = ecdf(MDR_sim[1,])
pval = ifelse(MDR_obs[1] > median(MDR_sim[1,]),
2*(1-cdf_mdr(MDR_sim[1,])),
2*cdf_mdr(MDR_sim[1,]))
pval
quantile(MDR_sim[1],p=c(0.025,0.975))
## Plotting some of the simulated MDR values
## MDR_sim has the same structure as MDR_sim_mock but was obtained with n_resamp=1000
hist(MDR_sim[1])
## Plotting some of the simulated MDR values
## MDR_sim has the same structure as MDR_sim_mock but was obtained with n_resamp=1000
hist(MDR_sim[1,])
## Plotting some of the simulated MDR values
## MDR_sim has the same structure as MDR_sim_mock but was obtained with n_resamp=1000
hist(MDR_sim[1,])
abline(v=MDR_obs[1],lwd=2,color="firebrick3)
## Plotting some of the simulated MDR values
## MDR_sim has the same structure as MDR_sim_mock but was obtained with n_resamp=1000
hist(MDR_sim[1,])
abline(v=MDR_obs[1],lwd=2,color="firebrick3")
## Plotting some of the simulated MDR values
## MDR_sim has the same structure as MDR_sim_mock but was obtained with n_resamp=1000
hist(MDR_sim[1,])
abline(v=MDR_obs[1],lwd=2,color="firebrick3")
## Plotting some of the simulated MDR values
## MDR_sim has the same structure as MDR_sim_mock but was obtained with n_resamp=1000
hist(MDR_sim[1,]);abline(v=MDR_obs[1],lwd=2,color="firebrick3")
## Plotting some of the simulated MDR values
## MDR_sim has the same structure as MDR_sim_mock but was obtained with n_resamp=1000
hist(MDR_sim[1,]);abline(v=MDR_obs[1],lwd=2,col="firebrick3")
MDR_sim[1]
## Plotting some of the simulated MDR values
## MDR_sim has the same structure as MDR_sim_mock but was obtained with n_resamp=1000
hist(MDR_sim[1,])
abline(v=MDR_obs[1],lwd=2,col="firebrick3")
## Plotting some of the simulated MDR values
## MDR_sim has the same structure as MDR_sim_mock but was obtained with n_resamp=1000
hist(MDR_sim[1,]) ; abline(v=MDR_obs[1],lwd=2,col="firebrick3")
## Plotting some of the simulated MDR values
## MDR_sim has the same structure as MDR_sim_mock but was obtained with n_resamp=1000
hist(MDR_sim[1,]) ; abline(v=MDR_obs[1],lwd=2,col=2)
## Plotting some of the simulated MDR values
## MDR_sim has the same structure as MDR_sim_mock but was obtained with n_resamp=1000
hist(MDR_sim[1,]) ; abline(v=MDR_obs[1],lwd=2,col=3)
hist(MDR_sim[1,]) ; abline(v=MDR_obs[1],lwd=2,col=3)
quantile(MDR_sim[1],p=c(0.025,0.975))
hist(MDR_sim[1,]) ; abline(v=MDR_obs[1],lwd=2,col=3)
quantile(MDR_sim[1],p=c(0.025,0.975))
MDR_obs[1]
abline(v=0.2)
plot(seq(0,10,1))
abline(v=6)
hist(runif(100))
abline(v=.5)
hist(MDR_sim[1,])
abline(v=.2)
MDR_obs[1]
library(MDR)
row.names(MDR_sim)
document()
setwd("/home/gilles/Dropbox/iPRI/projects/ToxPharm/MDR_package/MDR")
## connect local project or github repo
#use_github(auth_token = "37e8f5fd3b4bf0f1a407a694602c1f47b2122b43")
use_vignette("MDR")  # only once
document()
document()
document()
setwd("/home/gilles/Dropbox/iPRI/projects/ToxPharm/MDR_package/MDR")
document()
library(devtools)
library(roxygen2)
library(usethis)
document()
## check()
build()
install()
library(MDR)
%MDR_sim
MDR_sim
MDR_obs
library(MDR)
library(ggplot2)
library(gridExtra)
# library(bookdown)
## Plotting some of the simulated MDR values
## MDR_sim has the same structure as MDR_sim_mock but was obtained with n_resamp=1000
hist(MDR_sim[1,]) ; abline(v=MDR_obs[1],lwd=2,col=3)
quantile(MDR_sim[1],p=c(0.025,0.975))
cdf_mdr = ecdf(MDR_sim[1,])
pval = ifelse(MDR_obs[1] > median(MDR_sim[1,]),
2*(1-cdf_mdr(MDR_sim[1,])),
2*cdf_mdr(MDR_sim[1,]))
pval
## Plotting some of the simulated MDR values
## MDR_sim has the same structure as MDR_sim_mock but was obtained with n_resamp=1000
hist(MDR_sim[1,]) ; abline(v=MDR_obs[1],lwd=2,col=3)
quantile(MDR_sim[1],p=c(0.025,0.975))
## Plotting some of the simulated MDR values
## MDR_sim has the same structure as MDR_sim_mock but was obtained with n_resamp=1000
hist(MDR_sim[1,]) ; abline(v=MDR_obs[1],lwd=2,col=3)
pval = ifelse(MDR_obs[1] > median(MDR_sim[1,]),
2*(1-cdf_mdr(MDR_obs[1])),
2*cdf_mdr(MDR_obs[1]))
pval
quantile(MDR_sim[1,],p=c(0.025,0.975))
MDR_obs
summary(MDR_sim)
summary(MDR_sim[1,])
## Data about design
dat = tabulizer::extract_tables(file='/home/gilles/Dropbox/EFSA/EFSA_projects/SCER/Mixtures/Data/Crustacea DB/Crustacea/PDF/Crustacea_Included_InDatabase/DallaBona_2014.PDF',
pages= 2)
dallabona.sc
dallabona.mix
i=4
j=1
names = unique(dallabona.mix[,1:2])[i,]
name.a = unlist(names[1]) ; name.b = unlist(names[2])
names = unique(dallabona.mix[,1:2])[i,]
name.a = unlist(names[1]) ; name.b = unlist(names[2])
i.a = dallabona.sc[,1] == name.a # where to find info in single compound data dallabona.sc
r =  (dallabona.sc[i.a,'max'] / dallabona.sc[i.a,'min'])^(1/4)
dsc.a = dallabona.sc[i.a,'min'] * c(1,r,r^2,r^3,r^4)
i.b = dallabona.sc[,1] == name.b
r =  (dallabona.sc[i.b,'max'] / dallabona.sc[i.b,'min'])^(1/4)
dsc.b = dallabona.sc[i.b,'min'] * c(1,r,r^2,r^3,r^4)
w.max = dallabona.mix[j,'max.b'] / dallabona.mix[j,'max.a']
r.a = (dallabona.mix[j,'max.a'] / dallabona.mix[j,'min.a'])^(1/4)
dm.a = dallabona.mix[j,'min.a'] * c(1,r.a,r.a^2,r.a^3,r.a^4)
r.b = (dallabona.mix[j,'max.b'] / dallabona.mix[j,'min.b'])^(1/4)
dm.b = dallabona.mix[j,'min.b'] * c(1,r.b,r.b^2,r.b^3,r.b^4)
w = dallabona.mix$min.a/(dallabona.mix$min.a + dallabona.mix$min.b)
EC50.DA = 1/(w[j]/dallabona.sc$EC50[i.a] + (1-w[j])/dallabona.sc$EC50[i.b])
EC50.obs = dallabona.mix$EC50.a[j] + dallabona.mix$EC50.b[j]
MDR_obs[j] = EC50.DA / EC50.obs
MDR_obs[j]
i
i=1
j=1
names = unique(dallabona.mix[,1:2])[i,]
name.a = unlist(names[1]) ; name.b = unlist(names[2])
i.a = dallabona.sc[,1] == name.a # where to find info in single compound data dallabona.sc
r =  (dallabona.sc[i.a,'max'] / dallabona.sc[i.a,'min'])^(1/4)
dsc.a = dallabona.sc[i.a,'min'] * c(1,r,r^2,r^3,r^4)
i.b = dallabona.sc[,1] == name.b
r =  (dallabona.sc[i.b,'max'] / dallabona.sc[i.b,'min'])^(1/4)
dsc.b = dallabona.sc[i.b,'min'] * c(1,r,r^2,r^3,r^4)
w.max = dallabona.mix[j,'max.b'] / dallabona.mix[j,'max.a']
r.a = (dallabona.mix[j,'max.a'] / dallabona.mix[j,'min.a'])^(1/4)
dm.a = dallabona.mix[j,'min.a'] * c(1,r.a,r.a^2,r.a^3,r.a^4)
r.b = (dallabona.mix[j,'max.b'] / dallabona.mix[j,'min.b'])^(1/4)
dm.b = dallabona.mix[j,'min.b'] * c(1,r.b,r.b^2,r.b^3,r.b^4)
w = dallabona.mix$min.a/(dallabona.mix$min.a + dallabona.mix$min.b)
EC50.DA = 1/(w[j]/dallabona.sc$EC50[i.a] + (1-w[j])/dallabona.sc$EC50[i.b])
EC50.obs = dallabona.mix$EC50.a[j] + dallabona.mix$EC50.b[j]
MDR_obs[j] = EC50.DA / EC50.obs
MDR_obs
MDR_obs = rep(NA,nrow(dallabona.mix))
## put together info on design in form of three vectors (x,y,n)
x = c(dsc.a, rep(0,length(dsc.b)), dm.a)
y = c(rep(0,length(dsc.a)), dsc.b, dm.b)
n = rep(20,length(x)) # OECD 202 (cf section 2.3 of Dallabona)
x
y
n
dallabona.sc$EC50[i.a]
dallabona.sc$Hill.Slope[i.a]
dallabona.sc$EC50[i.b]
hist(MDR_sim[1,])
summary(MDR_sim[1,])
par(mfrow=c(2,2)) ; for(ii in 1:4){ hist(MDR_sim[ii,])}
SCDR_model
SCDR_model='Hill2'
par_Hill
par_Hill=c(a1=dallabona.sc$EC50[i.a],
b1=dallabona.sc$Hill.Slope[i.a],
a2=dallabona.sc$EC50[i.b],
b2=dallabona.sc$Hill.Slope[i.b])
par_Hill
simdat = Sim_Mixture(x=x,y=y,n=n,
SCDR_model=SCDR_model,
par_Hill=par_Hill,
interaction_model='Loewe',
par_int=NULL,
distribution=distribution,par_dist=1)
distribution='binom'
simdat = Sim_Mixture(x=x,y=y,n=n,
SCDR_model=SCDR_model,
par_Hill=par_Hill,
interaction_model='Loewe',
par_int=NULL,
distribution=distribution,par_dist=1)
res_MDR = Compute_MDR(x=simdat$x,y=simdat$y,
z=simdat$z,n=simdat$n,
SCDR_model=SCDR_model,
design=design,
lower = c(0.0001,0.0001,0.0001,0.0001) ,
upper = c(10,10,1,1) ,
do.plot=FALSE )
design='single-ray'
res_MDR = Compute_MDR(x=simdat$x,y=simdat$y,
z=simdat$z,n=simdat$n,
SCDR_model=SCDR_model,
design=design,
lower = c(0.0001,0.0001,0.0001,0.0001) ,
upper = c(10,10,1,1) ,
do.plot=FALSE )
res_MDR
res_MDR = Compute_MDR(x=simdat$x,y=simdat$y,
z=simdat$z,n=simdat$n,
SCDR_model=SCDR_model,
design=design,
lower = lower ,
upper = upper ,
do.plot=FALSE )
lower = c(0.0001,0.0001,0.0001,0.0001)
upper = c(1000,100,1,1)
res_MDR = Compute_MDR(x=simdat$x,y=simdat$y,
z=simdat$z,n=simdat$n,
SCDR_model=SCDR_model,
design=design,
lower = lower ,
upper = upper ,
do.plot=FALSE )
res_MDR
n_resamp = 1000
MDR_sim = matrix(nr=nrow(dallabona.mix),nc=n_resamp)
MDR_obs = nrow(dallabona.mix)
names = unique(dallabona.mix[,1:2])[i,]
name.a = unlist(names[1]) ; name.b = unlist(names[2])
i.a = dallabona.sc[,1] == name.a # where to find info in single compound data dallabona.sc
r =  (dallabona.sc[i.a,'max'] / dallabona.sc[i.a,'min'])^(1/4)
dsc.a = dallabona.sc[i.a,'min'] * c(1,r,r^2,r^3,r^4)
i.b = dallabona.sc[,1] == name.b
r =  (dallabona.sc[i.b,'max'] / dallabona.sc[i.b,'min'])^(1/4)
dsc.b = dallabona.sc[i.b,'min'] * c(1,r,r^2,r^3,r^4)
j=1
w.max = dallabona.mix[j,'max.b'] / dallabona.mix[j,'max.a']
r.a = (dallabona.mix[j,'max.a'] / dallabona.mix[j,'min.a'])^(1/4)
dm.a = dallabona.mix[j,'min.a'] * c(1,r.a,r.a^2,r.a^3,r.a^4)
r.b = (dallabona.mix[j,'max.b'] / dallabona.mix[j,'min.b'])^(1/4)
dm.b = dallabona.mix[j,'min.b'] * c(1,r.b,r.b^2,r.b^3,r.b^4)
w = dallabona.mix$min.a/(dallabona.mix$min.a + dallabona.mix$min.b)
EC50.DA = 1/(w[j]/dallabona.sc$EC50[i.a] + (1-w[j])/dallabona.sc$EC50[i.b])
EC50.obs = dallabona.mix$EC50.a[j] + dallabona.mix$EC50.b[j]
MDR_obs[j] = EC50.DA / EC50.obs
## put together info on design in form of three vectors (x,y,n)
x = c(dsc.a, rep(0,length(dsc.b)), dm.a)
y = c(rep(0,length(dsc.a)), dsc.b, dm.b)
n = rep(20,length(x)) # OECD 202 (cf section 2.3 of Dallabona)
res = Resample_MDR(x=x,y=y,n=n,
SCDR_model = "Hill2",
par_Hill=c(a1=dallabona.sc$EC50[i.a],
b1=dallabona.sc$Hill.Slope[i.a],
a2=dallabona.sc$EC50[i.b],
b2=dallabona.sc$Hill.Slope[i.b]),
lower = c(0.0001,0.0001,0.0001,0.0001) ,
upper = c(1000,100,1,1),
design='single-ray',
n_resamp=n_resamp,
distribution = "binom")
n_resamp = 3 ## set to 3 to save time when building package, should be set to e.g. 1000
MDR_sim_mock = matrix(nr=nrow(dallabona.mix),nc=n_resamp)
MDR_obs = rep(NA,nrow(dallabona.mix))
i
j
w.max = dallabona.mix[j,'max.b'] / dallabona.mix[j,'max.a']
r.a = (dallabona.mix[j,'max.a'] / dallabona.mix[j,'min.a'])^(1/4)
dm.a = dallabona.mix[j,'min.a'] * c(1,r.a,r.a^2,r.a^3,r.a^4)
r.b = (dallabona.mix[j,'max.b'] / dallabona.mix[j,'min.b'])^(1/4)
dm.b = dallabona.mix[j,'min.b'] * c(1,r.b,r.b^2,r.b^3,r.b^4)
w = dallabona.mix$min.a/(dallabona.mix$min.a + dallabona.mix$min.b)
EC50.DA = 1/(w[j]/dallabona.sc$EC50[i.a] + (1-w[j])/dallabona.sc$EC50[i.b])
EC50.obs = dallabona.mix$EC50.a[j] + dallabona.mix$EC50.b[j]
MDR_obs[j] = EC50.DA / EC50.obs
## put together info on design in form of three vectors (x,y,n)
x = c(dsc.a, rep(0,length(dsc.b)), dm.a)
y = c(rep(0,length(dsc.a)), dsc.b, dm.b)
n = rep(20,length(x)) # OECD 202 (cf section 2.3 of Dallabona)
res = Resample_MDR(x=x,y=y,n=n,
SCDR_model = "Hill2",
par_Hill=c(a1=dallabona.sc$EC50[i.a],
b1=dallabona.sc$Hill.Slope[i.a],
a2=dallabona.sc$EC50[i.b],
b2=dallabona.sc$Hill.Slope[i.b]),
lower = c(0.0001,0.0001,0.0001,0.0001) ,
upper = c(1000,100,1,1),
design='single-ray',
n_resamp=n_resamp,
distribution = "binom")
res
source('~/Dropbox/iPRI/projects/ToxPharm/MDR_package/MDR/R/Resample_MDR.R')
library(MDR)
library(MDR)
library(ggplot2)
library(gridExtra)
# library(bookdown)
n_resamp = 3 ## set to 3 to save time when building package, should be set to e.g. 1000
n_resamp = 3 ## set to 3 to save time when building package, should be set to e.g. 1000
MDR_sim_mock = matrix(nr=nrow(dallabona.mix),nc=n_resamp)
MDR_obs = rep(NA,nrow(dallabona.mix))
i=1
j=1
names = unique(dallabona.mix[,1:2])[i,]
name.a = unlist(names[1]) ; name.b = unlist(names[2])
i.a = dallabona.sc[,1] == name.a # where to find info in single compound data dallabona.sc
r =  (dallabona.sc[i.a,'max'] / dallabona.sc[i.a,'min'])^(1/4)
dsc.a = dallabona.sc[i.a,'min'] * c(1,r,r^2,r^3,r^4)
i.b = dallabona.sc[,1] == name.b
r =  (dallabona.sc[i.b,'max'] / dallabona.sc[i.b,'min'])^(1/4)
dsc.b = dallabona.sc[i.b,'min'] * c(1,r,r^2,r^3,r^4)
w.max = dallabona.mix[j,'max.b'] / dallabona.mix[j,'max.a']
r.a = (dallabona.mix[j,'max.a'] / dallabona.mix[j,'min.a'])^(1/4)
dm.a = dallabona.mix[j,'min.a'] * c(1,r.a,r.a^2,r.a^3,r.a^4)
r.b = (dallabona.mix[j,'max.b'] / dallabona.mix[j,'min.b'])^(1/4)
dm.b = dallabona.mix[j,'min.b'] * c(1,r.b,r.b^2,r.b^3,r.b^4)
w = dallabona.mix$min.a/(dallabona.mix$min.a + dallabona.mix$min.b)
EC50.DA = 1/(w[j]/dallabona.sc$EC50[i.a] + (1-w[j])/dallabona.sc$EC50[i.b])
EC50.obs = dallabona.mix$EC50.a[j] + dallabona.mix$EC50.b[j]
MDR_obs[j] = EC50.DA / EC50.obs
## put together info on design in form of three vectors (x,y,n)
x = c(dsc.a, rep(0,length(dsc.b)), dm.a)
y = c(rep(0,length(dsc.a)), dsc.b, dm.b)
n = rep(20,length(x)) # OECD 202 (cf section 2.3 of Dallabona)
res = Resample_MDR(x=x,y=y,n=n,
SCDR_model = "Hill2",
par_Hill=c(a1=dallabona.sc$EC50[i.a],
b1=dallabona.sc$Hill.Slope[i.a],
a2=dallabona.sc$EC50[i.b],
b2=dallabona.sc$Hill.Slope[i.b]),
lower = c(0.0001,0.0001,0.0001,0.0001) ,
upper = c(1000,100,1,1),
design='single-ray',
n_resamp=n_resamp,
distribution = "binom")
res
par_Hill=c(a1=dallabona.sc$EC50[i.a],
b1=dallabona.sc$Hill.Slope[i.a],
a2=dallabona.sc$EC50[i.b],
b2=dallabona.sc$Hill.Slope[i.b])
SCDR_model = "Hill2"
lower = c(0.0001,0.0001,0.0001,0.0001)
upper = c(1000,100,1,1)
design='single-ray'
n_resamp=n_resamp
distribution = "binom"
simdat = Sim_Mixture(x=x,y=y,n=n,
SCDR_model=SCDR_model,
par_Hill=par_Hill,
interaction_model='Loewe',
par_int=NULL,
distribution=distribution,par_dist=1)
res_MDR = Compute_MDR(x=simdat$x,y=simdat$y,
z=simdat$z,n=simdat$n,
SCDR_model=SCDR_model,
design=design,
lower = lower ,
upper = upper ,
do.plot=FALSE )
res_MDR
res = Resample_MDR(x=x,y=y,n=n,
SCDR_model = "Hill2",
par_Hill=c(a1=dallabona.sc$EC50[i.a],
b1=dallabona.sc$Hill.Slope[i.a],
a2=dallabona.sc$EC50[i.b],
b2=dallabona.sc$Hill.Slope[i.b]),
lower = c(0.0001,0.0001,0.0001,0.0001) ,
upper = c(1000,100,1,1),
design='single-ray',
n_resamp=n_resamp,
distribution = "binom")
res
par_Hill
setwd("/home/gilles/Dropbox/iPRI/projects/ToxPharm/MDR_package/MDR")
#
document()
library(devtools)
library(roxygen2)
library(usethis)
document() ; build() ; install()
